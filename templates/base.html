<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ site_name }} | {{ developer_name }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>

<body>
    <nav class="navbar">
        <div class="nav-brand">
            <a href="{{ url_for('home') }}">{{ developer_name }}.</a>
        </div>
        <button class="nav-toggle" id="navToggle" aria-label="메뉴 열기">
            <i class="fa-solid fa-bars"></i>
        </button>
        <div class="nav-links" id="navLinks">
            <a href="{{ url_for('home') }}#home" id="nav-home">홈 (Home)</a>
            <a href="{{ url_for('home') }}#projects" id="nav-projects">프로젝트 (Projects)</a>
            <a href="{{ github_url }}" target="_blank">GitHub</a>
        </div>
    </nav>

    <main>
        {% block content %}{% endblock %}
    </main>

    <footer>
        <p>&copy; 2024 {{ developer_name }}. All rights reserved.</p>
    </footer>

    <!-- Floating Action Buttons -->
    <div class="fab-container" id="fabContainer">
        <button class="fab-btn secondary" id="scrollToTop" aria-label="맨 위로">
            <i class="fa-solid fa-arrow-up"></i>
        </button>
        <button class="fab-btn" id="scrollToBottom" aria-label="맨 아래로">
            <i class="fa-solid fa-arrow-down"></i>
        </button>
    </div>

    <script>
        const navToggle = document.getElementById('navToggle');
        const navLinks = document.getElementById('navLinks');

        navToggle.addEventListener('click', () => {
            navLinks.classList.toggle('active');
            const icon = navToggle.querySelector('i');
            if (navLinks.classList.contains('active')) {
                icon.classList.replace('fa-bars', 'fa-xmark');
            } else {
                icon.classList.replace('fa-xmark', 'fa-bars');
            }
        });

        // Active State Logic
        document.addEventListener('DOMContentLoaded', () => {
            const sections = document.querySelectorAll('section, .category-section, .hero');
            const navItems = {
                'home': document.getElementById('nav-home'),
                'projects': document.getElementById('nav-projects')
            };

            // Options for IntersectionObserver
            const observerOptions = {
                root: null,
                rootMargin: '-20% 0px -70% 0px', // Trigger when section is near top/middle
                threshold: 0
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.id;

                        // Remove active class from all
                        Object.values(navItems).forEach(item => {
                            if (item) item.classList.remove('active');
                        });

                        // Add active class to current
                        if (id === 'home' && navItems['home']) {
                            navItems['home'].classList.add('active');
                        } else if (id === 'projects' && navItems['projects']) {
                            navItems['projects'].classList.add('active');
                        }
                    }
                });
            }, observerOptions);

            sections.forEach(section => {
                if (section.id) observer.observe(section);
            });

            // Carousel Logic
            const carousels = document.querySelectorAll('.carousel-container');

            carousels.forEach(carousel => {
                const wrapper = carousel.querySelector('.scrolling-wrapper');
                const progressBar = carousel.querySelector('.scroll-progress-bar');
                const prevBtn = carousel.querySelector('.prev');
                const nextBtn = carousel.querySelector('.next');

                if (!wrapper || !progressBar || !prevBtn || !nextBtn) return;

                // Update Progress Bar
                const updateProgress = () => {
                    const scrollLeft = wrapper.scrollLeft;
                    const scrollWidth = wrapper.scrollWidth;
                    const clientWidth = wrapper.clientWidth;
                    const maxScroll = scrollWidth - clientWidth;

                    if (maxScroll > 0) {
                        const widthPercentage = (scrollLeft / maxScroll) * 100;
                        progressBar.style.width = `${Math.min(100, Math.max(0, widthPercentage))}%`;
                    }
                };

                wrapper.addEventListener('scroll', updateProgress);
                // Initial update
                updateProgress();
                // Update on resize
                window.addEventListener('resize', updateProgress);

                // Navigation with Circular Logic
                const scrollAmount = 350 + 32; // card width + gap (approx)

                nextBtn.addEventListener('click', () => {
                    const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
                    // Tolerance for floating point calculation
                    if (wrapper.scrollLeft >= maxScroll - 5) {
                        // Loop to start
                        wrapper.scrollTo({ left: 0, behavior: 'smooth' });
                    } else {
                        wrapper.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    }
                });

                prevBtn.addEventListener('click', () => {
                    if (wrapper.scrollLeft <= 5) {
                        // Loop to end
                        wrapper.scrollTo({ left: wrapper.scrollWidth, behavior: 'smooth' });
                    } else {
                        wrapper.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    }
                });
            });

            // View Toggle Logic
            const toggleBtns = document.querySelectorAll('.view-toggle-btn');
            toggleBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetId = btn.getAttribute('data-target');
                    const targetContainer = document.getElementById(targetId);

                    if (targetContainer) {
                        if (targetContainer.classList.contains('view-grid')) {
                            targetContainer.classList.replace('view-grid', 'view-carousel');
                        } else {
                            targetContainer.classList.replace('view-carousel', 'view-grid');
                        }
                    }
                });
            });

            // FAB Logic
            const fabContainer = document.getElementById('fabContainer');
            const scrollTopBtn = document.getElementById('scrollToTop');
            const scrollBottomBtn = document.getElementById('scrollToBottom');

            // Initial check
            const updateFabVisibility = () => {
                const scrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;

                // Hide Up button if at top
                if (scrollY < 100) {
                    scrollTopBtn.classList.add('hidden');
                } else {
                    scrollTopBtn.classList.remove('hidden');
                }

                // Hide Down button if at bottom
                if (scrollY + windowHeight >= documentHeight - 100) {
                    scrollBottomBtn.classList.add('hidden');
                } else {
                    scrollBottomBtn.classList.remove('hidden');
                }
            };

            window.addEventListener('scroll', updateFabVisibility);
            // Call once to set initial state
            updateFabVisibility();

            scrollTopBtn.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            scrollBottomBtn.addEventListener('click', () => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            });

            // Scroll Animations Observer
            const fadeObserverOptions = {
                threshold: 0.1,
                rootMargin: "0px 0px -50px 0px"
            };

            const fadeObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                        observer.unobserve(entry.target); // Run once
                    }
                });
            }, fadeObserverOptions);

            const fadeElements = document.querySelectorAll('.fade-wrap');
            fadeElements.forEach(el => fadeObserver.observe(el));
        });
    </script>
    {% block scripts %}{% endblock %}
</body>

</html>